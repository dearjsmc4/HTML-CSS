### WWW
Who? 웹의 아버지. 팀 버너스 리. 

Why? 지리적으로 멀리있는 사람들을 연결해주기 위해 만들었을 것.

Wonder world : 개발자는 어찌보면 가상의 세계를 만드는 창조주.

### Web
백엔드 – 서버. 데이터베이스. 어플리케이션

프론트엔드 – 클라이언드. 웹브라우저. 프레젠테이션(보여주고 표현하는.)

- HTML : 건강한 신체. 뼈대를 만드는 용도.
- CSS : 근사한 스타일링. 옷을 입히고 꾸미기. 어떻게 보이는가는 스타일링의 차이점.
- Javascript : 스마트한 두뇌. 마네킹이 아닌, 살아있는 것처럼 만들기. 

- Web standards : 웹표준. 누가 만드는가? 월드와이드웹 consortiums. W3C.
( 제프리 젤드만의 웹표준 가이드. -> 강사님 추천 책. )

- Web accessibility : 웹 접근성.
웹의 힘은 보편성에 있다. 장애에 구애받지 않고 누구나 접근할 수 있어야 한다!
디자이너 눈에만 예쁘게 만드는 ui 는 ux 를 고려하지 않은 것. 
장애인에게 필요한 것은 줄기세포가 아니라 현실적인 정보기술. 
환경에 대한 장애가 있을수도 있고, 다양한 플랫폼, 크로스브라우징, 저사양 저속회선 등등의 문제.

Html의 문법적 약점? 

대소문자를 구별하지 않는 것. 닫는태그를 생략해도 문법적 오류가 아닌 것.


예외상황이 많아진다는건 기계처리에 문제가 생긴다는거. 이 문제를 해결? -> xml(Extensible markup language)


점점 컨텐츠에 대한 의미가 구체화됨. 


<학생><이름>황유순</이름></학생> 태그들을 이용하는 것.

- XHTML
1.	태그생략불가능
2.	꼭 닫아줘야함
3.	속성은 반드시 값을 가져야함. 


Charset 은 무조건 타이틀태그보다 먼저 써야함! 

타이틀이 한글일 수도 있으니까.


Html 은 인터프리터형식(위에서부터 하나씩 읽는 것)


타이틀은 페이지의 내용을 나타내는 중요한 단어로. 장식문자는 가급적 피할 것. 핵심단어를 타이틀 앞쪽에 쓰기.

-> SEO
순수검색엔진에서 내가 입력한 키워드만으로 상위에 노출될 수 있다면 홍보비를 줄일 수 있음! 

타이틀이 seo 관점에서 필요한 키워드가 될 수 있음. 

## 웹페이지구조의 기본 골격
3단: 헤더, 콘텐츠, 푸터 구조.

4단: 헤더, 네비게이션, 콘텐츠, 푸터 구조.

디자인과 별개로 콘텐츠의 논리적 흐름을 봐야함. 선형화구조!(디벨롭바에서 css걷어내면 보이는 구조)

하나의 html 구조를 가지고 멀티플 스타일을 주는게 좋음. 

그럴려면 콘텐츠에 집중해야하고, 콘텐츠가 논리적인 순서를 유지하고 있어야함. 

같은 로그인창 안에서도 아이디->비밀번호->로그인 버튼 순서. 이런 순서와 구조가 중요. 

언제 어디에 보여야하는지는 css에서 하면 되니까 html로는 구조를 신경쓸 것.



#### 1. 먼저 구조를 짠다 – 선형화단계.

#### 2. 시맨틱 요소를 명시한다 – 

과거엔 div 에 id를 붙여서 썼지만, 지금은 헤더 푸터 역할을 알려주는 태그들이 있음.

그런 요소를 갖다쓰는게 합리적임. 어떤 시맨틱요소를 쓰는 것이 좋을까 고민하는 단계임.

(Aside = 부가컨텐츠블록. 이 내용이 삭제되더라도 메인컨텐츠를 이용하는데에 문제가없어야함.)


- Wai-aria
Div 에 role 속성을 주면 해당 태그를 쓴것과 비슷한 역할을 담당한다고 기계한테 알려주는 것임.

만약 div로 짜인 페이지를 개선하고 싶으면 role을 쓰면 되고. -> 아리아방식

만약 처음부터 짜려면 시맨틱태그 쓰면 됨. -> 네이티브방식


버튼을 a태그로 만드는 이유:마우스, 키보드 둘다 이벤트를 걸수있도록 하기위해. (form도)

버튼태그는 기본디자인이 입혀져있고 보더박스사이징.

A 태그에 롤을 버튼으로 부여하면, 그것이 버튼이 되고 그렇게 동작함.


#### 3. 네이밍
흐름에 따라 줄 것.

주로 클래스이름으로 부여하고. 이름만 봐도 무엇인지 이해할 수 있도록.


### Css
박스모델은 매우 중요함.

- 기본값: 콘텐트(너비높이), 패딩, 마진, 보더값 전부더해서 콘텐트박스.
- 박스사이징: 너비높이에 보더와 패딩을 포함.

설계. 얼만한 크기로 어떻게? 설계도면 그리듯이 오차없이 그려야 함.


#### Flex 모델.
내가 마크업한 순서는 1,2,3. 

2번이 2번자리에 잇는 이유는 1번 다음에 놓았기 때문에.(노멀플로우)

만약에 2,1,3으로 놔야하면 마크업순서를 바꾸면되긴하지만 그건 디자인베이스배치임.

- 부모요소 -> 플랙스 컨테이너

Display: flex 이렇게 주면, 안의 아이템들이 가로방향(row direction)으로 배치 될 수 있음.

플랙스 다이렉션은 부모요소에 주는 것.

로우기본값이면 왼쪽이 플렉스 스타트, 리버스면 오른쪽이 플렉스 스타트.

컬럼기본값도 마찬가지.


- 자식요소 -> 플랙스 아이템
모든 아이템의 기본 시작은 0번. 마이너스를 주면 그보다 먼저 시작하게 됨.

아이템을 자유롭게 배치할수있음.



익스플로러 하위버전도 호환시켜야한다면 Flex 는 쓸 수 없음.

-> Float 를 쓰거나 inline 모델을 쓸 수 있음.

인라인은 박스와 박스 사이에 공백문자가 생겨남.

float: Left나 right값을 줌. 기본은 none값.

자식요소에 플로트 속성을 줘서, 부모상자의 왼쪽이나 오른쪽에 배치.

어떤 요소 위에 떠있게되면 밑 요소의 텍스트가 밀려남. 

그 밑에는 인라인 요소가 올 수 없기 때문임. 

만약 플로트할 공간이 부족하면, 유효한 라인박스까지 내려와서 붙음.

clear:both; 를 주면 플로트가 해제됨.

#### 가상요소

플로트된 아이템들 밑에 텍스트노드를 가지지않는, 존재하지만 보이지는 않는 요소를 만들어서

그 요소에 clear:both 를 준다.

:before, :after : 가상엘리먼트를 만들어주는 것

before: 첫 자식노드를 가상으로 만들어냄.

after: 마지막 자식노드를 가상으로 만들어냄.

이렇게 만들어진 가상요소들은 인라인 요소.

인라인요소는 클리어를 쓸 수 없음.

디스플레이를 블록으로 바꿔주어야 함.

그리고 content 가 있어야 하므로 content:""; 로 빈 콘텐츠를 만들어줌.
